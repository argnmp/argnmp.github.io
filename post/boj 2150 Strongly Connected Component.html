<!DOCTYPE html>
<html lang="en">
    <head>
        <title>blog.argnmp</title>
        
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="icon" href="data:,">
        <link href="/static/main.css" rel="stylesheet">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
        <script src="//cdnjs.cloudflare.com/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
        <script src="/static/entry_bundle.js"></script>
        <script src="/static/module_bundle.js" type="module"></script>
    </head>
    <body class="dark:bg-gray-800">
        <div class="p-5 sm:px-10 md:px-16 lg:container mx-auto lg:px-20 py-5 xl:px-48 box-border h-screen w-screen">
            <div class="flex text-customlight-700 dark:text-customdark-400 mb-4 border-b border-customlight-700 dark:border-customdark-400">
                <div class="grow">
                    <a class="inline-block" href="/">
                        <p
                            class="text-2xl font-bold hover:bg-customlight-700 hover:text-white dark:hover:bg-customdark-400 dark:hover:text-gray-800">
                        blog.argnmp</p>
                    </a>
                </div>
                <button id="searchToggle" class="cursor-pointer justify-center items-center p-2">
                    <svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5 stroke-gray-600 dark:stroke-gray-400"
                        viewBox="0 0 24 24" stroke-width="1.5" fill="none" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path stroke="none" d="M0 0h24v24H0z" fill="none" />
                        <path d="M10 10m-7 0a7 7 0 1 0 14 0a7 7 0 1 0 -14 0" />
                        <path d="M21 21l-6 -6" />
                    </svg>
                </button>
                <button id="toggle" class="cursor-pointer justify-center items-center p-2">
                    <svg xmlns="http://www.w3.org/2000/svg" class="dark:hidden w-4 h-4" viewBox="0 0 16 16">
                        <path class="fill-gray-600" d="M8 12a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM8 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 0zm0 13a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 13zm8-5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5zM3 8a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2A.5.5 0 0 1 3 8zm10.657-5.657a.5.5 0 0 1 0 .707l-1.414 1.415a.5.5 0 1 1-.707-.708l1.414-1.414a.5.5 0 0 1 .707 0zm-9.193 9.193a.5.5 0 0 1 0 .707L3.05 13.657a.5.5 0 0 1-.707-.707l1.414-1.414a.5.5 0 0 1 .707 0zm9.193 2.121a.5.5 0 0 1-.707 0l-1.414-1.414a.5.5 0 0 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .707zM4.464 4.465a.5.5 0 0 1-.707 0L2.343 3.05a.5.5 0 1 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .708z"/>
                    </svg>
                    <svg xmlns="http://www.w3.org/2000/svg" class="hidden dark:block w-4 h-4" viewBox="0 0 16 16">
                        <path class="fill-gray-400" d="M6 .278a.768.768 0 0 1 .08.858 7.208 7.208 0 0 0-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527 0 1.04-.055 1.533-.16a.787.787 0 0 1 .81.316.733.733 0 0 1-.031.893A8.349 8.349 0 0 1 8.344 16C3.734 16 0 12.286 0 7.71 0 4.266 2.114 1.312 5.124.06A.752.752 0 0 1 6 .278z"/>
                        <path class="fill-gray-400" d="M10.794 3.148a.217.217 0 0 1 .412 0l.387 1.162c.173.518.579.924 1.097 1.097l1.162.387a.217.217 0 0 1 0 .412l-1.162.387a1.734 1.734 0 0 0-1.097 1.097l-.387 1.162a.217.217 0 0 1-.412 0l-.387-1.162A1.734 1.734 0 0 0 9.31 6.593l-1.162-.387a.217.217 0 0 1 0-.412l1.162-.387a1.734 1.734 0 0 0 1.097-1.097l.387-1.162zM13.863.099a.145.145 0 0 1 .274 0l.258.774c.115.346.386.617.732.732l.774.258a.145.145 0 0 1 0 .274l-.774.258a1.156 1.156 0 0 0-.732.732l-.258.774a.145.145 0 0 1-.274 0l-.258-.774a1.156 1.156 0 0 0-.732-.732l-.774-.258a.145.145 0 0 1 0-.274l.774-.258c.346-.115.617-.386.732-.732L13.863.1z"/>
                    </svg>
                </button>
            </div>
            <div class="grid grid-cols-1 md:grid-cols-12 gap-2">
                <div class="md:col-span-3">
                    <div class="flex md:flex-col text-gray-900 dark:text-gray-200">
                        <div class="w-full md:object-center basis-1/4">
                          <img class="w-full max-w-sm mx-auto rounded-md ring-customlight-600 dark:ring-customdark-500" src="/static/profile image.png" />
                        </div>
                        <div class="grow pl-4 md:p-0 md:text-left my-auto">
                          <p class="text-xl md:mt-3 mb-2 font-bold">argnmp</p>
                          
                          <p class="text-xs">컴퓨터공학 관련 주제를 주로 다룹니다.</p>
                          
                          <p class="text-xs">argnmp@gmail.com</p>
                          
                          
                          
                          <p class="text-xs"><a class="text-xs" href="https://github.com/argnmp">github</a></p>
                          
                        </div>
                    </div>
                    <div id="toc" class="sticky top-5 mt-5 border-l-2">
                        <p class="pl-4 pb-1 text-sm text-gray-900 dark:text-gray-200 cursor-pointer hover:text-custom-light-700 dark:hover:text-custom-light-400 hover:font-bold hover:underline" hidden>to load styles for dynamically created elements</ul>
                    </div>
                </div>
                <div id="main" class="grid-flow-row md:col-span-9 rounded-lg">
                    <div id="searchModule" class="md:pl-3" hidden>
                        <div class="pb-2">
                            <form class="flex">
                                <input type="text" name="search" id="search_input" class="inline w-full rounded-md border-0 py-1 px-2 mr-2 text-gray-900 ring-1 ring-inset ring-gray-300 dark:ring-gray-700 placeholder:text-gray-400 focus:ring-1 focus:ring-inset focus:ring-customlight-600 dark:focus:ring-customdark-300 text-sm sm:leading-6 dark:bg-gray-800 dark:text-gray-200" placeholder="search for child nodes..." onkeyup="window.search()">
                            </form>
                        </div>
                        <div class="" id="search_result">
                            <a class="" href="">
                                <div class="mb-1 px-2 py-1 border border-gray-200 dark:border-gray-600 dark:text-gray-200 hidden">
                                </div> 
                            </a>
                        </div> 
                    </div>
                    
                    
                    <article>
                        <section class="w-full mb-12">
                            <div class="mb-2 md:pl-5">
                                <p class="text-4xl md:text-4xl break-keep font-semibold text-gray-700 dark:text-gray-200 py-1">boj 2150 Strongly Connected Component</p>
                                
                            </div>
                            <div class="flex flex-row mb-4 md:pl-5 text-gray-500 dark:text-gray-400">
                                <div class="mr-2"><p class="text-xs italic">Taehyeon Kim</p></div>
                                <div class="mr-2"><p class="text-xs italic">2024-01-10</p></div>
                                <div class="bg-customlight-100 bg-customlight-200 bg-customlight-300 bg-customlight-400 bg-customlight-500 bg-customlight-600 bg-customlight-700 bg-customlight-800 bg-customlight-900 dark:bg-customdark-100 dark:bg-customdark-200 dark:bg-customdark-300 dark:bg-customdark-400 dark:bg-customdark-500 dark:bg-customdark-600 dark:bg-customdark-700 dark:bg-customdark-800 dark:bg-customdark-900" hidden></div>
                                <div class="mr-2 flex flex-row">
                                    
                                    
                                    
                                    
                                    

                                    <div class="px-1 mr-1 bg-customlight-500 dark:bg-customdark-500 align-middle text-xs text-white rounded-md">
                                        boj
                                    </div>
                                    
                                    
                                    
                                    

                                    <div class="px-1 mr-1 bg-customlight-600 dark:bg-customdark-600 align-middle text-xs text-white rounded-md">
                                        ps
                                    </div>
                                    
                                    
                                </div>
                            </div>
                        </section>
                        <div class="clear-none markdown-body mb-10 md:pl-5 leading-6 font-post">
                            <h3 id="문제">문제</h3>
<p><a href="https://www.acmicpc.net/problem/2150">https://www.acmicpc.net/problem/2150</a></p>
<h3 id="풀이">풀이</h3>
<p>방향 그래프에서 정점의 최대 부분집합들을 구해야 하는데, 각 부분 집합에 속한 정점들은 양방향으로 도달 가능해야 한다.</p>
<p>이러한 부분집합을 이루가 위해서는, 집합에 속한 정점들 간에 <strong>사이클</strong>이 존재해야 한다. 그래야 각 정점의 조합들이 양방향으로 도달할 수 있게 된다.</p>
<p>따라서 문제는 최대 크기의 사이클에 속한 정점들의 집합을 찾는 것이 된다.</p>
<h4 id="union-find와 dfs를 이용한 풀이">union-find와 dfs를 이용한 풀이</h4>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;map&gt;
#include &lt;unordered_map&gt;
#include &lt;set&gt;
#include &lt;unordered_set&gt;
#include &lt;bitset&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
using namespace std;
using ll = long long;
int v, e;
vector&lt;vector&lt;int&gt;&gt; graph(10001, vector&lt;int&gt;());
int uf[10001] = {0,};
int uf_find(int node){
    if(uf[node]==node)
        return node;
    return uf[node] = uf_find(uf[node]);
}
bool uf_union(int a, int b){
    // cout &lt;&lt; &quot;union: &quot; &lt;&lt; a &lt;&lt; ' ' &lt;&lt; b &lt;&lt; endl;
    int ap = uf_find(a);
    int bp = uf_find(b);
    if(ap!=bp){
        uf[bp] = ap; 
        return false;
    }
    return true;
}

vector&lt;int&gt;stk;
int done[10001] = {0,}; //0: white, 1: gray, 2: black
void calc(int node){
    done[node] = 1;
    stk.push_back(node);
    for(int next: graph[node]){
        if(done[next]==2){
            bool do_union = false;
            for(int i = 0; i&lt;stk.size(); i++){
                if(!do_union &amp;&amp; uf_find(next)==uf_find(stk[i])){
                    uf_union(next, stk[i]);
                    do_union = true;
                } else if(do_union){
                    uf_union(next, stk[i]);
                }
            }
            continue; 
        }
        if(done[next]==1){
            int t = stk.size()-2;
            while(stk[t]!=next){
                uf_union(node, stk[t]);
                t--;
            }
            uf_union(node, stk[t]);
            continue;
        }
        calc(next);
    }
    stk.pop_back();
    done[node] = 2;
}
void solve(){
    cin &gt;&gt; v &gt;&gt; e; 
    for(int i = 1; i&lt;=v; i++){
        uf[i] = i; 
    }
    int a, b;
    for(int i = 0; i&lt;e; i++){
        cin &gt;&gt; a &gt;&gt; b; 
        graph[a].push_back(b); 
    }
    for(int i = 1; i&lt;=v; i++){
        if(done[i]==0)
            calc(i);

    }
    vector&lt;vector&lt;int&gt;&gt; ans;
    int visited[10001] = {0,};
    for(int i = 1; i&lt;=v; i++){
        if(visited[i]==1)
            continue;
        int par = uf_find(i);
        vector&lt;int&gt; t; 
        t.push_back(i);
        visited[i] = 1;
        for(int k = i+1; k&lt;=v; k++){
            if(uf_find(k)==par){
                t.push_back(k);
                visited[k] = 1;
            }
        }
        ans.push_back(t);
    }
    cout &lt;&lt; ans.size() &lt;&lt; '\n';
    for(vector&lt;int&gt; t: ans){
        for(int elem: t){
            cout &lt;&lt; elem &lt;&lt; ' ';
        }
        cout &lt;&lt; &quot;-1\n&quot;;
    }
    
}
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    solve(); 
    return 0;
}

</code></pre>
<p>처음 생각한 풀이이다.</p>
<p>먼저 stack을 하나 생성하고, <code>done</code>배열을 준비한다. <code>done</code>배열에서는 dfs를 수행하는 과정에서 방문한 정점의 상태를 기록한다. 정점의 상태는 다음과 같다.</p>
<ul>
<li>0: 아직 방문하지 않은 정점</li>
<li>1: dfs로 해당 정점에 도달했지만, 모든 edge에 대한 탐색이 완료되지 않은 정점</li>
<li>2: dfs로 해당 정점에 도달한 뒤, 모든 edge에 대한 탐색이 완료된 정점</li>
</ul>
<p>그리고 union-find 알고리즘을 위한 배열을 준비한다.</p>
<p>각 정점의 <code>done</code>배열의 값이 0인 경우, 즉 방문하지 않은 정점인 경우 dfs를 수행한다. 위의 코드에서는 <code>calc</code> 함수이다.</p>
<p><code>calc</code>함수에서는 다음과 같은 작업을 한다.</p>
<ul>
<li>done 배열의 현재 정점의 값을 1로 만들어주고, stack에 현재 정점을 넣는다.</li>
<li>현재 정점에 연결된 다른 정점들을 탐색한다
<ul>
<li>다른 정점의 상태가 2인 경우, 이는 탐색이 완료된 정점이다. 이는 다른 정점이 현재 정점까지의 경로에 들어 있지 않는 것을 의미한다. stack에 들어있는 값은 현재 노드까지의 지나온 경로를 의미한다. 따라서 stack의 가장 처음(하단)부터 끝(상단)까지 순서대로 보면서 다른 정점이 있는지 확인한다. 만약 있다면, 그 이후의 stack에 들어있는 정점에 대해서는 다른 정점과 union을 수행한다.</li>
<li>다른 정점의 상태가 1인 경우, 이는 탐색이 진행중인 정점이다. 이는 다른 정점이 현재 정점까지의 경로에 들어 있는 것을 의미한다. stack의 끝(상단) 부터 역방향으로 순서대로 보면서, 다른 정점을 만날 때까지 현재 정점과 union을 수행한다.</li>
<li>다른 정점의 상태가 0인 경우, 아직 방문하지 않은 정점이다. 따라서 <code>calc</code> 함수를 재귀 호출한다.</li>
</ul>
</li>
<li>다른 정점들에 대한 탐색이 끝나면 stack에서 현재 정점을 빼주고, done 배열의 현재 정점의 값을 2로 만들어준다.</li>
</ul>
<p>이렇게 해서 boj에 제출하니, 448ms 시간으로 <code>맞았습니다</code>를 받았다.</p>
<p>해설을 찾아보니, 이는 ssc 문제로 kosaraju 알고리즘과 tarjan 알고리즘으로 풀 수 있다. 아래는 두 알고리즘을 사용한 풀이이다.
<a href="/">scc</a></p>
<h4 id="kosaraju 알고리즘을 활용한 풀이">kosaraju 알고리즘을 활용한 풀이</h4>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;map&gt;
#include &lt;unordered_map&gt;
#include &lt;set&gt;
#include &lt;unordered_set&gt;
#include &lt;bitset&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
using namespace std;
using ll = long long;
int v, e;
vector&lt;vector&lt;int&gt;&gt; graph(10001, vector&lt;int&gt;());
vector&lt;vector&lt;int&gt;&gt; rgraph(10001, vector&lt;int&gt;());
vector&lt;int&gt; tmp;
vector&lt;vector&lt;int&gt;&gt; scc;
struct sort_vec{
    bool operator()(vector&lt;int&gt;&amp;a, vector&lt;int&gt;&amp;b){
        return a[0] &lt; b[0];
    }
};
int done[10001] = {0,};
void dfs(int v){
    done[v] = 1; 
    for(int next: graph[v]){
        if(done[next]==1)
            continue;
        dfs(next);
    }
    tmp.push_back(v);
}
void rdfs(int v){
    done[v] = 1; 
    for(int next: rgraph[v]){
        if(done[next]==1)
            continue;
        rdfs(next);
    }
    tmp.push_back(v);
}
void kosaraju(){
    for(int i = 1; i&lt;=v; i++){
        if(done[i]==0)
            dfs(i);
    }
    vector&lt;int&gt; stk = tmp;
    memset(done, 0, sizeof(done));
    while(!stk.empty()){
        int cur = stk.back();
        stk.pop_back(); 
        if(done[cur]==1)
            continue;
        tmp = vector&lt;int&gt;();
        rdfs(cur); 
        sort(tmp.begin(), tmp.end());
        scc.push_back(tmp);
    }
    sort(scc.begin(), scc.end(), sort_vec()); 
}
void solve(){
    cin &gt;&gt; v &gt;&gt; e;
    int a, b;
    while(e--){
        cin &gt;&gt; a &gt;&gt; b; 
        graph[a].push_back(b);
        rgraph[b].push_back(a);
    }
    kosaraju();    
    cout &lt;&lt; scc.size() &lt;&lt; '\n';
    for(vector&lt;int&gt; tmp: scc){
        for(int t: tmp)
            cout &lt;&lt; t &lt;&lt; ' ';
        cout &lt;&lt; &quot;-1\n&quot;;
    }
}
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    solve(); 
    return 0;
}

</code></pre>
<p>kosaraju 알고리즘에서는 역방향 그래프도 생성해주어야 한다.</p>
<p>주어진 그래프에서 dfs 탐색을 하며, 먼저 return 되는 정점 순서대로 stack에 넣는다. 이후 stack에서 pop되는 정점 순서대로 dfs 탐색을 했을 때, 한번의 dfs 탐색에서 방문하게 되는 전체 정점이 하나의 scc 집합이 된다.</p>
<h4 id="tarjan 알고리즘을 활용한 풀이">tarjan 알고리즘을 활용한 풀이</h4>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;map&gt;
#include &lt;unordered_map&gt;
#include &lt;set&gt;
#include &lt;unordered_set&gt;
#include &lt;bitset&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
using namespace std;
using ll = long long;
int v, e;
vector&lt;vector&lt;int&gt;&gt; graph(10001, vector&lt;int&gt;());
vector&lt;vector&lt;int&gt;&gt; scc;
struct sort_vec{
    bool operator()(vector&lt;int&gt; a, vector&lt;int&gt; b){
        return a[0] &lt; b[0];
    }
};
vector&lt;int&gt; stk;
int gid = 1;
int id[10001] = {0,};
int done[10001] = {0,};
int tarjan(int node){
    stk.push_back(node);
    id[node] = gid; 
    gid += 1;
    int parent = id[node];
    for(int next: graph[node]){
        if(id[next]==0)
            parent = min(parent, tarjan(next));
        else if(done[next]==0)
            parent = min(parent, id[next]);
    } 
    if(parent == id[node]){
        vector&lt;int&gt; t;
        while(1){
            int cur = stk.back();
            stk.pop_back();
            t.push_back(cur);
            done[cur] = 1;
            if(cur==node)
                break;
        }
        sort(t.begin(), t.end());
        scc.push_back(t);
    }
    
    return parent;
}
void solve(){
    cin &gt;&gt; v &gt;&gt; e; 
    int a, b;
    for(int i = 0; i&lt;e; i++){
        cin &gt;&gt; a &gt;&gt; b;
        graph[a].push_back(b);
    }
    for(int i = 1; i&lt;=v; i++){
        if(id[i]==0)
            tarjan(i);
    }
    sort(scc.begin(), scc.end(), sort_vec());
    cout &lt;&lt; scc.size() &lt;&lt; '\n';
    for(vector&lt;int&gt; g: scc){
        for(int t: g){
            cout &lt;&lt; t &lt;&lt; ' ';
        } 
        cout &lt;&lt; &quot;-1\n&quot;;
    }
}
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    solve(); 
    return 0;
}

</code></pre>
<p>tarjan 알고리즘은 kosaraju 알고리즘에 비해 dfs 탐색을 한번만 하기 때문에 더 빠르다.</p>
<h3 id="느낀점">느낀점</h3>
<p>처음에 union-find를 활용하여 문제를 풀었으나, 시간이 오래 걸렸다. 앞으로는 kosaraju's 와 tarjan's 알고리즘을 활용하자.</p>

                        </div>
                    </article>

                </div>
            </div> 
            <footer class="py-4 text-sm text-gray-700 dark:text-gray-200 text-center">
                © 2023. Taehyeon Kim All rights reserved. 
            </footer>
        </div>
    </body>
</html>
